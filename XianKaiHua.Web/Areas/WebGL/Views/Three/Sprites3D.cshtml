@{
    ViewData["Title"] = "SceneIndex";
    Layout = "~/Views/Shared/_Layout.cshtml";
}
<html>
<head>
    <title>css3d-sprites</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style type="text/css">
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: Monospace;
            font-size: 13px;
            line-height: 24px;
            overscroll-behavior: none;
        }

        a {
            color: #ff0;
            text-decoration: none;
        }

            a:hover {
                text-decoration: underline;
            }

        button {
            cursor: pointer;
            text-transform: uppercase;
        }

        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            pointer-events: none;
            z-index: 1; /* TODO Solve this in HTML */
        }

        a, button, input, select {
            pointer-events: auto;
        }

        .lil-gui {
            z-index: 2 !important; /* TODO Solve this in HTML */
        }

        @@media all and ( max-width: 640px ) {
            .lil-gui.root {
                right: auto;
                top: auto;
                max-height: 50%;
                max-width: 80%;
                bottom: 0;
                left: 0;
            }
        }

        #overlay {
            position: absolute;
            font-size: 16px;
            z-index: 2;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background: rgba(0,0,0,0.7);
        }

            #overlay button {
                background: transparent;
                border: 0;
                border: 1px solid rgb(255, 255, 255);
                border-radius: 4px;
                color: #ffffff;
                padding: 12px 18px;
                text-transform: uppercase;
                cursor: pointer;
            }

        #notSupported {
            width: 50%;
            margin: auto;
            background-color: #f00;
            margin-top: 20px;
            padding: 10px;
        }
    </style>
    <style>
        body {
            background-color: #fff;
            color: #000;
        }

        a {
            color: #48f;
        }
    </style>
</head>
<body>
    <div id="info">@*<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> css3d - sprites*@</div>
    <div id="container"></div>
    <script type="module">
        
        import * as THREE from '/lib/three-dev/build/three.module.js';
        import { OrbitControls } from '/lib/three-dev/examples/jsm/controls/OrbitControls.js';
        import Stats from '/lib/three-dev/examples/jsm/libs/stats.module.js';
        import { GUI } from '/lib/three-dev/examples/jsm/libs/lil-gui.module.min.js';
        import { RoomEnvironment } from '/lib/three-dev/examples/jsm/environments/RoomEnvironment.js';
        import { GLTFLoader } from '/lib/three-dev/examples/jsm/loaders/GLTFLoader.js';
        import { DRACOLoader } from '/lib/three-dev/examples/jsm/loaders/DRACOLoader.js';
        import { CSS3DRenderer, CSS3DObject } from '/lib/three-dev/examples/jsm/renderers/CSS3DRenderer.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeeeeee);
        scene.fog = new THREE.Fog(0xd50c7b, 10, 50);

        const camera = new THREE.PerspectiveCamera(75,window.innerWidth / window.innerHeight,0.1,1000);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        let grid = new THREE.GridHelper(100, 40, 0x000000, 0x000000);//绘制网格
        grid.material.opacity = 0.1;
        grid.material.depthWrite = false;
        grid.material.transparent = true;
        scene.add(grid);


        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.background = new THREE.Color(0x3e87d3);

        const loader = new THREE.TextureLoader();
        const texture = loader.load('/lib/three-dev/examples/textures/kandao3.jpg');

        const geometry = new THREE.BoxGeometry();
        const material = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            wireframe: true,
            map: texture,
        });

        const cube = new THREE.Mesh(geometry, material);//对象
        scene.add(cube);

        cube.add(new THREE.AxesHelper(5));//坐标轴线

        camera.position.z = 2;

        //自动窗口
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }

        const stats = Stats();
        document.body.appendChild(stats.dom);

        //gui
        const gui = new GUI();
        const cubeFolder = gui.addFolder('Cube');
        const cubeRotationFolder = cubeFolder.addFolder('Rotation');//弧度旋转
        cubeRotationFolder.add(cube.rotation, 'x', 0, Math.PI * 2, 0.01);
        cubeRotationFolder.add(cube.rotation, 'y', 0, Math.PI * 2, 0.01);
        cubeRotationFolder.add(cube.rotation, 'z', 0, Math.PI * 2, 0.01);

        const cubePositionFolder = cubeFolder.addFolder('Position');//物体位置坐标姿势
        cubePositionFolder.add(cube.position, 'x', -10, 10);
        cubePositionFolder.add(cube.position, 'y', -10, 10);
        cubePositionFolder.add(cube.position, 'z', -10, 10);

        const cubeScaleFolder = cubeFolder.addFolder('Scale');//物体缩放尺寸及规模
        cubeScaleFolder.add(cube.scale, 'x', -5, 5, 0.1);
        cubeScaleFolder.add(cube.scale, 'y', -5, 5, 0.1);
        cubeScaleFolder.add(cube.scale, 'z', -5, 5, 0.1);

        const cubequaternionFolder = cubeFolder.addFolder('Quaternion');//四元数局部旋转
        cubequaternionFolder.add(cube.quaternion, 'x', 0, 2);
        cubequaternionFolder.add(cube.quaternion, 'y', 0, 2);
        cubequaternionFolder.add(cube.quaternion, 'z', 0, 2);

        cubeFolder.add(cube, 'receiveShadow', false);//材质阴影
        cubeFolder.add(cube, 'renderOrder', 0, 20);//渲染顺序
        cubeFolder.add(cube, 'visible', true);//显示
        cubeFolder.open();

        const cameraFolder = gui.addFolder('Camera');//距离缩放
        cameraFolder.add(camera.position, 'x', 0, 10, 0.01);
        cameraFolder.add(camera.position, 'y', 0, 10, 0.01);
        cameraFolder.add(camera.position, 'z', 0, 10, 0.01);
        cameraFolder.open();



        var animate = function () {

            const time = - performance.now() / 1000;

            grid.position.z = - (time) % 5;

            requestAnimationFrame(animate);

            controls.update();

            render();

            stats.update();
        };

        function render() {
            renderer.render(scene, camera);
        }
        animate();
       /* */
    </script>
    <script type="module">
        /*
        import * as THREE from '/lib/three-dev/build/three.module.js';
        import { RGBELoader } from '/lib/three-dev/examples/jsm/loaders/RGBELoader.js';
        import { Lensflare, LensflareElement } from '/lib/three-dev/examples/jsm/objects/Lensflare.js';
        import { Reflector } from '/lib/three-dev/examples/jsm/objects/Reflector.js';
        import { VRButton } from '/lib/three-dev/examples/jsm/webxr/VRButton.js';

        import { HTMLMesh } from '/lib/three-dev/examples/jsm/interactive/HTMLMesh.js';
        import { InteractiveGroup } from '/lib/three-dev/examples/jsm/interactive/InteractiveGroup.js';
        import { XRControllerModelFactory } from '/lib/three-dev/examples/jsm/webxr/XRControllerModelFactory.js';

        import { GUI } from '/lib/three-dev/examples/jsm/libs/lil-gui.module.min.js';

        let camera, scene, renderer;
        let reflector;

        const parameters = {
            radius: 0.6,
            tube: 0.2,
            tubularSegments: 150,
            radialSegments: 20,
            p: 2,
            q: 3,
            thickness: 0.5
        };

        init();
        animate();

        function init() {

            scene = new THREE.Scene();

            new RGBELoader()
                .setPath('/lib/three-dev/examples/textures/equirectangular/')
                .load('moonless_golf_1k.txt', function (texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;

                    scene.background = texture;
                    scene.environment = texture;
                });

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
            camera.position.set(0, 1.6, 1.5);
            //

            const torusGeometry = new THREE.TorusKnotGeometry(...Object.values(parameters));
            const torusMaterial = new THREE.MeshPhysicalMaterial({
                transmission: 1.0, roughness: 0, metalness: 0.25, thickness: 0.5
            });
            const torus = new THREE.Mesh(torusGeometry, torusMaterial);
            torus.name = 'torus';
            torus.position.y = 1.5;
            torus.position.z = - 2;
            scene.add(torus);

            const cylinderGeometry = new THREE.CylinderGeometry(1, 1, 0.1, 50);
            const cylinderMaterial = new THREE.MeshStandardMaterial();
            const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinder.position.z = - 2;
            scene.add(cylinder);

            // lensflare
            const loader = new THREE.TextureLoader();
            const texture0 = loader.load('/lib/three-dev/examples/textures/lensflare/lensflare0.png');
            const texture3 = loader.load('/lib/three-dev/examples/textures/lensflare/lensflare3.png');

            const lensflare = new Lensflare();
            lensflare.position.set(0, 5, - 5);
            lensflare.addElement(new LensflareElement(texture0, 700, 0));
            lensflare.addElement(new LensflareElement(texture3, 60, 0.6));
            lensflare.addElement(new LensflareElement(texture3, 70, 0.7));
            lensflare.addElement(new LensflareElement(texture3, 120, 0.9));
            lensflare.addElement(new LensflareElement(texture3, 70, 1));
            scene.add(lensflare);

            //

            reflector = new Reflector(new THREE.PlaneGeometry(2, 2), {
                textureWidth: window.innerWidth * window.devicePixelRatio,
                textureHeight: window.innerHeight * window.devicePixelRatio
            });
            reflector.position.x = 1;
            reflector.position.y = 1.5;
            reflector.position.z = - 3;
            reflector.rotation.y = - Math.PI / 4;
            // TOFIX: Reflector breaks transmission
            // scene.add( reflector );

            const frameGeometry = new THREE.BoxGeometry(2.1, 2.1, 0.1);
            const frameMaterial = new THREE.MeshPhongMaterial();
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.z = - 0.07;
            reflector.add(frame);

            //

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.autoClear = false;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            document.body.appendChild(VRButton.createButton(renderer));

            window.addEventListener('resize', onWindowResize);

            //

            const geometry = new THREE.BufferGeometry();
            geometry.setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, - 5)]);

            const controller1 = renderer.xr.getController(0);
            controller1.add(new THREE.Line(geometry));
            scene.add(controller1);

            const controller2 = renderer.xr.getController(1);
            controller2.add(new THREE.Line(geometry));
            scene.add(controller2);

            //

            const controllerModelFactory = new XRControllerModelFactory();

            const controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);

            const controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);

            // GUI

            function onChange() {

                torus.geometry.dispose();
                torus.geometry = new THREE.TorusKnotGeometry(...Object.values(parameters));

            }

            function onThicknessChange() {

                torus.material.thickness = parameters.thickness;

            }

            const gui = new GUI({ width: 300 });
            gui.add(parameters, 'radius', 0.0, 1.0).onChange(onChange);
            gui.add(parameters, 'tube', 0.0, 1.0).onChange(onChange);
            gui.add(parameters, 'tubularSegments', 10, 150, 1).onChange(onChange);
            gui.add(parameters, 'radialSegments', 2, 20, 1).onChange(onChange);
            gui.add(parameters, 'p', 1, 10, 1).onChange(onChange);
            gui.add(parameters, 'q', 0, 10, 1).onChange(onChange);
            gui.add(parameters, 'thickness', 0, 1).onChange(onThicknessChange);
            gui.domElement.style.visibility = 'hidden';

            const group = new InteractiveGroup(renderer, camera);
            scene.add(group);

            const mesh = new HTMLMesh(gui.domElement);
            mesh.position.x = - 0.75;
            mesh.position.y = 1.5;
            mesh.position.z = - 0.5;
            mesh.rotation.y = Math.PI / 4;
            mesh.scale.setScalar(2);
            group.add(mesh);

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function animate() {

            renderer.setAnimationLoop(render);

        }

        function render() {

            const time = performance.now() * 0.0002;
            const torus = scene.getObjectByName('torus');
            torus.rotation.x = time * 2;
            torus.rotation.y = time * 5;

            renderer.render(scene, camera);

        }
        /**/
    </script>

    <script type="module">
        /*
            import * as THREE from '/lib/three-dev/build/three.module.js';

            import {TWEEN} from '/lib/three-dev/examples/jsm/libs/tween.module.min.js';
            import {TrackballControls} from '/lib/three-dev/examples/jsm/controls/TrackballControls.js';
            import {CSS3DRenderer, CSS3DSprite} from '/lib/three-dev/examples/jsm/renderers/CSS3DRenderer.js';

            let camera, scene, renderer;
            let controls;

            const particlesTotal = 512;
            const positions = [];
            const objects = [];
            let current = 0;

            init();
            animate();

            function init() {

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 5000);
                camera.position.set(600, 400, 1500);
                camera.lookAt(0, 0, 0);

                scene = new THREE.Scene();

                const image = document.createElement('img');
                image.addEventListener('load', function () {

                    for (let i = 0; i < particlesTotal; {

                        const object = new CSS3DSprite(image.cloneNode());
                        object.position.x = Math.random() * 4000 - 2000,
                            object.position.y = Math.random() * 4000 - 2000,
                            object.position.z = Math.random() * 4000 - 2000;
                        scene.add(object);

                        objects.push(object);

                    }

                    transition();

                });
                image.src = '/lib/three-dev/examples/textures/sprite.png';

                // Plane

                const amountX = 16;
                const amountZ = 32;
                const separationPlane = 150;
                const offsetX = ((amountX - 1) * separationPlane) / 2;
                const offsetZ = ((amountZ - 1) * separationPlane) / 2;

                for (let i = 0; i < particlesTotal; {

                    const x = (i % amountX) * separationPlane;
                    const z = Math.floor(i / amountX) * separationPlane;
                    const y = (Math.sin(x * 0.5) + Math.sin(z * 0.5)) * 200;

                    positions.push(x - offsetX, y, z - offsetZ);

                }

                // Cube

                const amount = 8;
                const separationCube = 150;
                const offset = ((amount - 1) * separationCube) / 2;

                for (let i = 0; i < particlesTotal; {

                    const x = (i % amount) * separationCube;
                    const y = Math.floor((i / amount) % amount) * separationCube;
                    const z = Math.floor(i / (amount * amount)) * separationCube;

                    positions.push(x - offset, y - offset, z - offset);

                }

                // Random

                for (let i = 0; i < particlesTotal; {

            positions.push(
                Math.random() * 4000 - 2000,
                Math.random() * 4000 - 2000,
                Math.random() * 4000 - 2000
            );

                }

                // Sphere

                const radius = 750;

                for (let i = 0; i < particlesTotal; {

                    const phi = Math.acos(- 1 + (2 * i) / particlesTotal);
                    const theta = Math.sqrt(particlesTotal * Math.PI) * phi;

                    positions.push(
                        radius * Math.cos(theta) * Math.sin(phi),
                        radius * Math.sin(theta) * Math.sin(phi),
                        radius * Math.cos(phi)
                    );

                }

                //

                renderer = new CSS3DRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('container').appendChild(renderer.domElement);

                //

                controls = new TrackballControls(camera, renderer.domElement);

                //

                window.addEventListener('resize', onWindowResize);

            }

            function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);

            }

            function transition() {

                const offset = current * particlesTotal * 3;
                const duration = 2000;

                for (let i = 0, j = offset; i < particlesTotal; {

                    const object = objects[i];

                    new TWEEN.Tween(object.position)
                        .to({
            x: positions[j],
                            y: positions[j + 1],
                            z: positions[j + 2]
                        }, Math.random() * duration + duration)
                        .easing(TWEEN.Easing.Exponential.InOut)
                        .start();

                }

                new TWEEN.Tween(this)
                    .to({ }, duration * 3)
                    .onComplete(transition)
                    .start();

                current = (current + 1) % 4;

            }

            function animate() {

            requestAnimationFrame(animate);

                TWEEN.update();
                controls.update();

                const time = performance.now();

                for (let i = 0, l = objects.length; i < l; {

                    const object = objects[i];
                    const scale = Math.sin((Math.floor(object.position.x) + time) * 0.002) * 0.3 + 1;
                    object.scale.set(scale, scale, scale);

                }

                renderer.render(scene, camera);

            }
        */
    </script>
</body>
</html>